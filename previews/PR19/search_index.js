var documenterSearchIndex = {"docs":
[{"location":"generated/tutorial/lmm_clusterdepth/","page":"MixedModels EEG + Cluster permutation test","title":"MixedModels EEG + Cluster permutation test","text":"important: Important\nThis functionality is not extensively tested. While it returns reasonable results, we haven't written any unit-tests, nor tested the type-1 error probability yet","category":"section"},{"location":"generated/tutorial/lmm_clusterdepth/#0.-Setup","page":"MixedModels EEG + Cluster permutation test","title":"0. Setup","text":"If you want to do LMM + cluster permutations, you at least need these packages (more for the simulation below)\n\nusing UnfoldMixedModels\nusing MixedModelsPermutations, ClusterDepth\nusing UnfoldStats","category":"section"},{"location":"generated/tutorial/lmm_clusterdepth/#1.-Simulate-data","page":"MixedModels EEG + Cluster permutation test","title":"1. Simulate data","text":"This section can be skipped, if one already has (real) data that they want to analyse.\n\n<details>\n<summary>Click to expand the simulation details</summary>\n\nusing UnfoldSim\nusing StatsModels\nusing Random\n\nsrate = 25\ndesign = MultiSubjectDesign(;\n    n_subjects = 30,\n    n_items = 40,\n    items_between = Dict(:stimtype => [\"car\", \"face\"]),\n)\n#both_within = Dict(:condition=>[\"scrambled\",\"intact\"]))\ncontrasts = Dict(:stimtype => DummyCoding())\np1 = MixedModelComponent(;\n    basis = UnfoldSim.p100(; sfreq = srate),\n    formula = @formula(dv ~ 1 + (1 | subject) + (1 | item)),\n    Î² = [5.0],\n    Ïƒs = Dict(:subject => [0.0], :item => [0.0]),\n    contrasts = contrasts,\n);\n\nn1 = MixedModelComponent(;\n    basis = UnfoldSim.n170(; sfreq = srate),\n    formula = @formula(dv ~ 1 + stimtype + (1 + stimtype | subject) + (1 | item)),\n    Î² = [1.0, 4], # n170-basis is negative\n    Ïƒs = Dict(:subject => [2.0, 0.25], :item => [0.25]),\n    contrasts = contrasts,\n);\n\np3 = MixedModelComponent(;\n    basis = UnfoldSim.p300(; sfreq = srate),\n    formula = @formula(dv ~ 1 + (1 | subject) + (1 + stimtype | item)),\n    Î² = [4.0],\n    Ïƒs = Dict(:subject => [1.0], :item => [0.5, 2]),\n    contrasts = contrasts,\n);\n\n\n\ndata_e, events = UnfoldSim.simulate(\n    design,\n    [p1, n1, p3],\n    UniformOnset(srate * 2, 10),\n    PinkNoise(; noiselevel = 1);\n    return_epoched = true,\n)\ntimes = range(-0.1, 0.5, length = size(data_e, 1))\ndata_e = reshape(data_e, 1, size(data_e, 1), :)\nnothing ##hide\n\n</details >","category":"section"},{"location":"generated/tutorial/lmm_clusterdepth/#2.-Fit-mass-univariate-LMMs","page":"MixedModels EEG + Cluster permutation test","title":"2. Fit mass-univariate LMMs","text":"We have some typical experimental data with subject and item effects. Item refer to stimuli here, based on our stimtype condition these are either different cars or faces.\n\nm = fit(\n    UnfoldModel,\n    [\n        Any => (\n            @formula(0 ~ 1 + stimtype + (1 + stimtype | item) + (1 + stimtype | subject)),\n            times,\n        ),\n    ],\n    events,\n    data_e,\n);\nnothing #hide","category":"section"},{"location":"generated/tutorial/lmm_clusterdepth/#3.-Cluster-permutation-test","page":"MixedModels EEG + Cluster permutation test","title":"3. Cluster permutation test","text":"If we would run a statistical test on each time-point separately, we would greatly inflate the type-1 error, reaching significance on any each sample much higher than the assumed Î±=0.05. One solution are cluster permutation test, where we instead test for clustersizes of connected significant clusters. In \"classical\" two-stage testing, such a permutation test is straight forward. But for LMMs we have to think of something more clever, as it is not directly clear how to permute if both subject and item effects exist (you gonna break the relation between the two). We did that in MixedModelsPermutations and can apply this strategy to EEG data as well.`\n\nselect the fixed-effects coefficient to test (stimtype)\n\ncoefficient = 2;\nnothing #hide\n\ncall the permutation test\n\nnote: Note\nThis interface is very likely to change in the future\n\npvalue(\n    MersenneTwister(1),\n    m,\n    data_e,\n    coefficient;\n    n_permutations = 20,\n    clusterforming_threshold = 1.8,\n)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"api/#API-/-Docstrings","page":"API / Docstrings","title":"API / Docstrings","text":"","category":"section"},{"location":"api/#UnfoldStats.contained_or_equal-Tuple{Any, Any}","page":"API / Docstrings","title":"UnfoldStats.contained_or_equal","text":"contained_or_equal(p, e)\n\nTest if p equals e or whether e contains p if e is a tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldStats.extract_coefs-Tuple{Unfold.UnfoldModel, Any, Any}","page":"API / Docstrings","title":"UnfoldStats.extract_coefs","text":"extract_coefs(model::UnfoldModel, predictor, basisname)\n\nReturn the coefficients of an Unfold model for a certain predictor and basisname.\n\nFor extracting the terms of a predictor variable predictor must be a symbol e.g. :continuous. For extracting the intercept predictor should be a String, i.e. \"(Intercept)\".\n\nbasisname must match one of the basis names which can be found in coeftable(model).\n\nNote: If a predictor variable has more than one term in the formula (e.g. a spline set, a categorical variable with several levels or an interaction), the coefficients for all terms are returned.\n\nThe dimensions of the returned coefficients are channel x times x coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldStats.extract_coefs-Tuple{Vector{<:Unfold.UnfoldModel}, Any, Any}","page":"API / Docstrings","title":"UnfoldStats.extract_coefs","text":"extract_coefs(models::Vector{<:UnfoldModel}, predictor, basisname)\n\nWhen applied to a vector of Unfold models, extracts the coefficients (matching the predictor and basisname) for all models (usually subjects) and concatenates them.\n\nThe dimensions of the returned coefficients are channel x times x coefficients x subjects.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldStats.extract_symbol-Tuple{StatsModels.AbstractTerm}","page":"API / Docstrings","title":"UnfoldStats.extract_symbol","text":"extract_symbol(t::AbstractTerm)\n\nReturn the symbol(s) underlying a term from a model formula, repeated by their actual coefficient number (after StatsModels.apply_schema).\n\nExamples\n\njulia> f = @formula 0 ~ 1 + spl(continuous, 4) + continuous + condition + pet + condition & pet\njulia> ... # apply schema using an event dataframe, according to StatsModels\njulia> extract_symbol(f)\n8-element Vector{Any}:\n \"(Intercept)\"\n :continuous\n :continuous\n :continuous\n :continuous\n :condition\n :pet\n (:condition, :pet)\n\nWe get the actual symbols of each predictor - this is different to a function that would return the symbol for each term, which would be [\"(Intercept)\", :continuous,:continuous,:condition,:pet,(:condition,:pet) ]\n\nThe difference between those two cases would get even more stark, if a basisfunction is in play as it timeexpand terms into many more predictors.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldStats.get_predictor_string-Tuple{Symbol}","page":"API / Docstrings","title":"UnfoldStats.get_predictor_string","text":"get_predictor_string(p)\n\nReturn string representation based on the type of p.\n\nThis function is used for a useful display of variables e.g. in an error message.\n\nExamples\n\njulia> UnfoldStats.get_predictor_string(:condition)\n\":condition\"\n\n\n\n\n\n","category":"method"},{"location":"tutorial/test_single_coefficient/#Unfold-single-parameter-cluster-permutation-testing","page":"Two-stage single parameter test (t-test)","title":"Unfold single parameter cluster permutation testing","text":"This is an adaptation of the ClusterDepth.jl tutorial.\n\nWe simulate a 1x2 design and perform cluster permutation testing via the ClusterDepth.jl package","category":"section"},{"location":"tutorial/test_single_coefficient/#Simulate-data","page":"Two-stage single parameter test (t-test)","title":"Simulate data","text":"Let's create data from 20 subjects\n\n <details>\n <summary>Click to expand the simulation details</summary>\n\nusing Random\nusing CairoMakie\nusing UnfoldSim\nusing Unfold\nusing UnfoldMakie\nusing Statistics\nusing ClusterDepth\nusing DataFrames\nusing Distributions\n\nn_subjects = 20\ndata,events = UnfoldSim.predef_eeg(n_subjects;return_epoched=true)\ntimes = range(0,step=1/100,length=size(data,1))\n\nnothing #hide\n\n </details >","category":"section"},{"location":"tutorial/test_single_coefficient/#Fitting-regression-Models","page":"Two-stage single parameter test (t-test)","title":"Fitting regression Models","text":"Fit an UnfoldModel to each subject:\n\nformula = @formula(0 ~ 1 + condition)\nmodels = map((d, ev) -> (fit(UnfoldModel, formula, DataFrame(ev), collect(d), times), ev.subject[1]),\n    eachslice(data; dims=3),\n    groupby(events, :subject))\nnothing #hide\n\n\nnow we can inspect the data easily, and extract the face-effect\n\nfunction add_subject!(df, s)\n    df[!, :subject] .= s\n    return df\nend\nallEffects = map((x) -> (effects(Dict(:condition => [\"car\", \"face\"]), x[1]), x[2]) |> (x) -> add_subject!(x[1], x[2]), models) |> e -> reduce(vcat, e)\n\nplot_erp(allEffects; mapping=(color=:condition, group=:subject))\n\nextract the face-coefficient from the linear model\n\nallCoefs = map(m -> (coeftable(m[1]), m[2]) |> (x) -> add_subject!(x[1], x[2]), models) |> e -> reduce(vcat, e)\nplot_erp(allCoefs; mapping=(group=:subject, col=:coefname))\n\nlet's unstack the tidy-coef table into a matrix and put it to clusterdepth for clusterpermutation testing\n\nfaceCoefs = allCoefs |> x -> subset(x, :coefname => x -> x .== \"condition: face\")\nerpMatrix = unstack(faceCoefs, :subject, :time, :estimate) |> x -> Matrix(x[:, 2:end])' |> collect\nsummary(erpMatrix)","category":"section"},{"location":"tutorial/test_single_coefficient/#Clusterdepth","page":"Two-stage single parameter test (t-test)","title":"Clusterdepth","text":"\npvals = clusterdepth(erpMatrix; Ï„=quantile(TDist(n_subjects - 1), 0.95), nperm=5000);\nnothing #hide\n\nwell - that was fast, less than a second for a cluster permutation test. not bad at all!","category":"section"},{"location":"tutorial/test_single_coefficient/#Plotting","page":"Two-stage single parameter test (t-test)","title":"Plotting","text":"Some plotting, and we add the identified cluster\n\nfirst calculate the ERP\n\nfaceERP = groupby(faceCoefs, [:time, :coefname]) |>\n          x -> combine(x, :estimate => mean => :estimate,\n    :estimate => std => :stderror);\nnothing #hide\n\nput the significance into a dataframe-form\n\nsignificant_regions_df = ClusterDepth.cluster(pvals .<= 0.05) |> x -> DataFrame(:from => times[x[1]], :to => times[x[1] .+ x[2]] , :coefname => \"condition: face\")\n\nand plot it!\n\nplot_erp(faceERP; stderror=true, significance=significant_regions_df)\n\nLooks good to me! We identified the cluster :-)","category":"section"},{"location":"generated/tutorial/test_splines/#Two-stage-EEG-analysis-using-Unfold-and-UnfoldStats","page":"Two-stage multi parameter test (Hotelling's T-squared test)","title":"Two-stage EEG analysis using Unfold & UnfoldStats","text":"","category":"section"},{"location":"generated/tutorial/test_splines/#0.-Setup","page":"Two-stage multi parameter test (Hotelling's T-squared test)","title":"0. Setup","text":"Load required packages.\n\nusing UnfoldStats\nusing Unfold\nusing DataFrames\nusing Chain\nusing Statistics\nusing HypothesisTests\nusing CairoMakie\nusing UnfoldMakie","category":"section"},{"location":"generated/tutorial/test_splines/#1.-Simulate-data","page":"Two-stage multi parameter test (Hotelling's T-squared test)","title":"1. Simulate data","text":"This section can be skipped, if one already has (real) data that they want to analyse.\n\n<details>\n<summary>Click to expand the simulation details</summary>\n\nusing UnfoldSim\nusing StableRNGs\n\ndesign = MultiSubjectDesign(\n    n_subjects = 20,\n    n_items = 100,\n    items_between = Dict(:continuous => range(0, 2, length = 10)),\n)\n\nÎ² = [1, 1, 0.5, 0.2]\nÏƒs = Dict(:subject => [1, 0.1, 0.1, 0.1])\n\nsignal = MixedModelComponent(;\n    basis = UnfoldSim.hanning(50),\n    formula = @formula(\n        0 ~\n            1 +\n            continuous +\n            continuous^2 +\n            continuous^3 +\n            (1 + continuous + continuous^2 + continuous^3 | subject)\n    ),\n    Î² = Î²,\n    Ïƒs = Ïƒs,\n)\n\nhart = Hartmut()\nsignal_multichannel = MultichannelComponent(signal, hart => \"Left Postcentral Gyrus\")\n\nonset = UniformOnset(; width = 50, offset = 60)\nnoise = PinkNoise(; noiselevel = 5)\n\n</details >\n\ndata, events = UnfoldSim.simulate(\n    StableRNG(1),\n    design,\n    signal_multichannel,\n    onset,\n    noise,\n    return_epoched = false,\n);\nnothing #hide\n\n<details>\n<summary>Click to expand event data frame </summary>\n\nfirst(events, 12)\n\n</details >","category":"section"},{"location":"generated/tutorial/test_splines/#2.-Fit-an-Unfold-model-for-each-subject-(first-stage)","page":"Two-stage multi parameter test (Hotelling's T-squared test)","title":"2. Fit an Unfold model for each subject (first stage)","text":"In the first stage, we fit an Unfold model for each subject separately.\n\n# Specify a temporal basis function\nbasisfunction = firbasis((-0.1, 0.7), 100)\n\n# Specify the model formula\nformula = @formula 0 ~ 1 + spl(continuous, 4)\n\n# Combine basisfunction and formula in an event dict\nevent_vec = [Any => (formula, basisfunction)]\n\nsubject_list = unique(events.subject)\nmodel_list = UnfoldLinearModelContinuousTime[]\n\n# Slice the data by its last dimension (i.e. the subject dimension)\ndata_slices = eachslice(data, dims = ndims(data))\n\nfor s = 1:size(data, ndims(data))\n    m = fit(\n        UnfoldModel,\n        event_vec,\n        subset(events, :subject => ByRow(==(subject_list[s]))),\n        data_slices[s],\n    )\n    push!(model_list, m)\nend\n\nmodels = DataFrame(subject = subject_list, unfoldmodel = model_list);\nsize(models)\n\nAs a result, we get a dataframe which contains an Unfold model for each subject.","category":"section"},{"location":"generated/tutorial/test_splines/#3.-Compute-and-visualize-the-marginal-effects","page":"Two-stage multi parameter test (Hotelling's T-squared test)","title":"3. Compute and visualize the marginal effects","text":"In the next step, we will compute the marginal effects of the continuous predictor i.e. how the prediction changes for different levels of this predictor. First, we compute the marginal effects separately for each subject. Then we aggregate them over subjects using the mean.\n\n# Specify the predictors of interest\npredictor_dict = Dict(:continuous => range(0, 2, length = 3))\n\n# Compute the marginal effects for all subjects separately\neffects_all_subjects = combine(\n    groupby(models, :subject),\n    :unfoldmodel => (m -> effects(predictor_dict, m[1])) => AsTable,\n)\n\n# Aggregate the marginal effects (per event type, time point and channel) over subjects\n# using the mean as aggregation function\naggregated_effects = @chain effects_all_subjects begin\n    groupby([:eventname, :channel, collect(keys(predictor_dict))..., :time])\n    combine(:yhat .=> [x -> mean(skipmissing(x))] .=> Symbol(\"yhat_\", mean))\nend;\nfirst(aggregated_effects, 5)\n\nNext, we want to visualize the marginal effects in a topoplot series. For this we first need to extract the electrode positions for our simulated data (or your real data) and project them from 3d to 2d.\n\n# Extract the electrode positions for the simulated data from the headmodel\n# and project them from 3d to 2d.\npos3d = hart.electrodes[\"pos\"];\npos2d = to_positions(pos3d')\npos2d = [Point2f(p[1] + 0.5, p[2] + 0.5) for p in pos2d];\nnothing #hide\n\nFor visualization, we use the plot_topoplotseries function from UnfoldMakie. In the topoplot series, the time in seconds (binned in time windows) is represented from left to right. The rows (from top to bottom) represent the marginal effects for different levels of the predictor continuous.\n\n# Set the size of the time bins for the topoplot series\nbin_width = 0.1\naggregated_effects.estimate = aggregated_effects.yhat_mean # bug in UnfoldMakie 0.5.12\nf_effects = Figure(size = (1200, 600))\ntp_effects = plot_topoplotseries!(\n    f_effects,\n    aggregated_effects;\n    bin_width,\n    positions = pos2d,\n    mapping = (; y = :estimate, row = :continuous),\n    visual = (; enlarge = 0.6, label_scatter = false, colorrange = (-3, 3)),\n)\n\nax = current_axis()\nlinkaxes!(tp_effects.content[1:end-2]...)\nxlims!(ax, 0, 0.9)\nylims!(ax, 0, 0.9)\ncurrent_figure()\n\nIn the time windows [0.1, 0.2), [0.2, 0.3) and [0.3, 0.4), one can see the effect of continuous that we simulated. In the next section, we want to quantify and test this effect.","category":"section"},{"location":"generated/tutorial/test_splines/#4.-Extract-coefficients-and-conduct-Hotelling's-T-tests","page":"Two-stage multi parameter test (Hotelling's T-squared test)","title":"4. Extract coefficients & conduct Hotelling's TÂ² tests","text":"We will use a one-sample Hotelling's TÂ² test to test whether at least one of the spline coefficients is different from 0. First, we extract the spline coefficients (for the continuous predictor variable) for all subjects. Then we conduct a Hotelling's TÂ² test separately for each channel and time point and extract the correspoding p-value.\n\n# Extract the spline coefficients for the `continuous` predictor variable\n# from the Unfold models of all subjects\neventname = unique(effects_all_subjects.eventname)\ncoefs = extract_coefs(models.unfoldmodel, :continuous, eventname)\n\n# Conduct a one-sample Hotelling's TÂ² test separately for all channels and time points\n# and compute a p-value. We compare the spline coefficients vector against 0.\np_values =\n    mapslices(c -> pvalue(OneSampleHotellingT2Test(c', [0, 0, 0])), coefs, dims = (3, 4)) |>\n    x -> dropdims(x, dims = (3, 4));\n\ntimes = unique(effects_all_subjects.time)\nchannels = axes(p_values, 1)\n\n# For visualization purposes, save the p_values in a data frame together with time and channel\np_values_df = DataFrame(\n    channel = repeat(channels, outer = length(times)),\n    time = repeat(times, inner = length(channels)),\n    p_values = p_values[:],\n);\n\nfirst(p_values_df, 5)\n\nAs a last step, we visualize the p-values in a topoplot series.\n\nbin_width = 0.1\np_values_df.estimate = p_values_df.p_values\nf_pvalues = Figure(size = (1200, 200))\ntp_pvalues = plot_topoplotseries!(\n    f_pvalues,\n    p_values_df;\n    bin_width,\n    positions = pos2d,\n    mapping = (; y = :estimate),\n    visual = (;\n        enlarge = 0.6,\n        label_scatter = false,\n        colorrange = (0, 0.1),\n        colormap = :Reds,\n    ),\n    colorbar = (; label = \"p-value\", limits = (0, 0.1), ticks = ([0.0, 0.1], [\"0\", \"0.1\"])),\n)\n\nax = current_axis()\ncurrent_figure()\n\nnote: Note\nTo decide whether to consider the effect statistically significant and to correct for multiple comparisons (due to different time points and channels), one could conduct a cluster-permutation test using the Hotelling's TÂ² values as the test statistic.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#UnfoldStats.jl-Documentation","page":"Home","title":"UnfoldStats.jl Documentation","text":"Welcome to UnfoldStats.jl: a Julia package for statistical testing of EEG/ERP data and Unfold.jl models.\n\n<div style=\"width:60%; margin: auto;\">\n</div>","category":"section"},{"location":"#Key-features","page":"Home","title":"Key features","text":"TBD","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"julia> using Pkg; Pkg.add(\"UnfoldStats\")\n\nFor more detailed instructions please refer to Installing Julia & Unfold Packages.","category":"section"},{"location":"#Usage-example","page":"Home","title":"Usage example","text":"TBD","category":"section"},{"location":"#Where-to-start:-Learning-roadmap","page":"Home","title":"Where to start: Learning roadmap","text":"","category":"section"},{"location":"#1.-First-steps","page":"Home","title":"1. First steps","text":"ðŸ“Œ Goal: TBD \nðŸ”— TBD","category":"section"},{"location":"#2.-Intermediate-topics","page":"Home","title":"2. Intermediate topics","text":"ðŸ“Œ Goal: TBD \nðŸ”— TBD","category":"section"},{"location":"#3.-Advanced-topics","page":"Home","title":"3. Advanced topics","text":"ðŸ“Œ Goal: TBD \nðŸ”— TBD","category":"section"},{"location":"#Statement-of-need","page":"Home","title":"Statement of need","text":"TBD\n\n<!---\nNote: The statement of need is also used in the `README.md`. Make sure that they are synchronized.\n-->","category":"section"}]
}
